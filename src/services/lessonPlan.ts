import { sendMessage } from "./api";
import { jsPDF } from "jspdf";
import PptxGenJS from "pptxgenjs";

interface LessonSection {
  id: string;
  title: string;
  keyPoints: string;
}

export const generateLessonPlan = async (topic: string, sections: LessonSection[]) => {
  const prompt = `Create a detailed mathematics lesson plan for the topic: "${topic}"

Please structure the lesson plan according to these sections:

${sections.map(section => `
${section.title}:
${section.keyPoints}
`).join('\n')}

Please provide:
1. A detailed, step-by-step lesson plan
2. Clear learning objectives
3. Engaging activities and examples
4. Assessment questions
5. Homework assignments
6. Additional resources or materials needed

Make the content engaging and suitable for primary school students. Include real-world examples and practical applications where possible.`;

  try {
    const response = await sendMessage(prompt);
    return response.text;
  } catch (error) {
    console.error("Error generating lesson plan:", error);
    throw new Error("Failed to generate lesson plan");
  }
};

export const exportToPDF = async (content: string, topic: string) => {
  try {
    // Create a new PDF document
    const doc = new jsPDF();
    
    // Define basic constants
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    const primaryColor = '#9b87f5';
    
    // Initialize page number and position
    let pageNum = 1;
    let yPos = 20; // Start position for content
    
    // Add header to first page
    doc.setFillColor(primaryColor);
    doc.rect(0, 0, pageWidth, 20, 'F');
    doc.setTextColor('#ffffff');
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text('MOTHER OF MATH', pageWidth / 2, 12, { align: 'center' });
    doc.setFontSize(10);
    doc.text(`Page ${pageNum}`, pageWidth - 25, 12);
    
    // Add title
    yPos = 40;
    doc.setTextColor('#333333');
    doc.setFontSize(22);
    doc.setFont('helvetica', 'bold');
    const titleLines = doc.splitTextToSize(topic, contentWidth);
    doc.text(titleLines, pageWidth / 2, yPos, { align: 'center' });
    
    // Update position after title
    yPos += (titleLines.length * 8) + 10;
    
    // Add underline
    doc.setDrawColor(primaryColor);
    doc.setLineWidth(0.5);
    doc.line(40, yPos - 5, pageWidth - 40, yPos - 5);
    
    // Add date
    doc.setFontSize(10);
    doc.setFont('helvetica', 'italic');
    const today = new Date().toLocaleDateString();
    doc.text(`Created on: ${today}`, pageWidth / 2, yPos, { align: 'center' });
    
    // Update position for content
    yPos += 20;
    
    // Process content
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(12);
    
    // Split content into sections
    const sections = content.split('\n\n');
    
    // Process each section
    for (const section of sections) {
      if (!section.trim()) continue;
      
      // Check if we need a page break
      if (yPos > 250) {
        // Add footer to current page
        doc.setFontSize(8);
        doc.text('Generated by Mother of Math', pageWidth / 2, 285, { align: 'center' });
        
        // Add new page
        doc.addPage();
        pageNum++;
        
        // Add header to new page
        doc.setFillColor(primaryColor);
        doc.rect(0, 0, pageWidth, 20, 'F');
        doc.setTextColor('#ffffff');
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.text('MOTHER OF MATH', pageWidth / 2, 12, { align: 'center' });
        doc.setFontSize(10);
        doc.text(`Page ${pageNum}`, pageWidth - 25, 12);
        
        // Reset position
        yPos = 40;
      }
      
      // Set font based on content type
      if (section === section.toUpperCase() || section.startsWith('#')) {
        // Heading
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(14);
        doc.setTextColor('#333333');
        
        const headingText = section.startsWith('#') ? section.substring(1).trim() : section;
        const headingLines = doc.splitTextToSize(headingText, contentWidth);
        
        doc.text(headingLines, margin, yPos);
        yPos += (headingLines.length * 7) + 5;
      } 
      else if (section.includes('\n') && (section.startsWith('- ') || section.startsWith('* '))) {
        // Bullet points
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(12);
        doc.setTextColor('#333333');
        
        const bullets = section.split('\n');
        
        for (const bullet of bullets) {
          if (!bullet.trim()) continue;
          
          // Check for page break within bullet list
          if (yPos > 250) {
            // Add footer
            doc.setFontSize(8);
            doc.text('Generated by Mother of Math', pageWidth / 2, 285, { align: 'center' });
            
            // Add new page
            doc.addPage();
            pageNum++;
            
            // Add header
            doc.setFillColor(primaryColor);
            doc.rect(0, 0, pageWidth, 20, 'F');
            doc.setTextColor('#ffffff');
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('MOTHER OF MATH', pageWidth / 2, 12, { align: 'center' });
            doc.setFontSize(10);
            doc.text(`Page ${pageNum}`, pageWidth - 25, 12);
            
            // Reset position
            yPos = 40;
            
            // Reset text style for bullets
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(12);
            doc.setTextColor('#333333');
          }
          
          const bulletText = bullet.replace(/^[-*]\s/, '');
          const bulletLines = doc.splitTextToSize(bulletText, contentWidth - 10);
          
          // Add bullet marker
          doc.text('â€¢', margin, yPos);
          
          // Add bullet text
          doc.text(bulletLines, margin + 5, yPos);
          
          // Update position
          yPos += (bulletLines.length * 6) + 4;
        }
      } 
      else {
        // Regular paragraph
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(12);
        doc.setTextColor('#333333');
        
        const paraLines = doc.splitTextToSize(section, contentWidth);
        
        doc.text(paraLines, margin, yPos);
        yPos += (paraLines.length * 6) + 6;
      }
    }
    
    // Add footer to last page
    doc.setFontSize(8);
    doc.text('Generated by Mother of Math', pageWidth / 2, 285, { align: 'center' });
    
    // Save the PDF
    doc.save(`${topic.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_lesson_plan.pdf`);
    
    return true;
  } catch (error) {
    console.error('Error generating PDF:', error);
    return false;
  }
};

export const exportToPowerPoint = async (content: string, topic: string) => {
  const pptx = new PptxGenJS();
  
  // Define Mother of Math branding colors
  const primaryColor = '9b87f5'; // Purple from the favicon
  const darkColor = '333333';
  const lightColor = 'ffffff';
  const accentColor = '6a4de7'; // Darker purple for emphasis
  
  // Set the master slide background and theme
  pptx.defineLayout({ name: 'MAMA_MATH', width: 10, height: 5.625 });
  pptx.layout = 'MAMA_MATH';
  
  // Create a background for all slides
  pptx.defineSlideMaster({
    title: 'MAMA_MASTER',
    background: { color: 'F9F8FF' }, // Very light purple background
    objects: [
      // Header bar
      { rect: { x: 0, y: 0, w: '100%', h: 0.5, fill: { color: primaryColor } } },
      
      // Footer with logo text
      { text: {
          text: 'MOTHER OF MATH',
          options: {
            x: 0.5, y: 5.1, w: 4, h: 0.3,
            color: primaryColor,
            fontFace: 'Arial',
            fontSize: 10,
            bold: true
          }
        }
      },
      
      // Slide number
      { text: {
          text: 'SLIDE_NUM / TOTAL_SLIDES',
          options: {
            x: 8.5, y: 5.1, w: 1, h: 0.3,
            color: darkColor,
            fontFace: 'Arial',
            fontSize: 10
          }
        }
      }
    ],
    slideNumber: { x: 8.5, y: 5.1 }
  });
  
  // Create title slide
  const titleSlide = pptx.addSlide({ masterName: 'MAMA_MASTER' });
  
  // Add main title
  titleSlide.addText(topic, {
    x: 0.5,
    y: 1.5,
    w: 9,
    h: 1.5,
    fontSize: 40,
    color: primaryColor,
    bold: true,
    align: 'center',
    fontFace: 'Arial',
    valign: 'middle',
    wrap: true
  });
  
  // Add subtitle
  titleSlide.addText('Lesson Plan', {
    x: 0.5,
    y: 3,
    w: 9,
    h: 0.5,
    fontSize: 24,
    color: accentColor,
    align: 'center',
    fontFace: 'Arial'
  });
  
  // Add date
  const today = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
  
  titleSlide.addText(`Created on: ${today}`, {
    x: 0.5,
    y: 3.5,
    w: 9,
    h: 0.5,
    fontSize: 16,
    color: darkColor,
    align: 'center',
    italic: true,
    fontFace: 'Arial'
  });
  
  // Add Mother of Math branded element
  titleSlide.addText('MOTHER OF MATH', {
    x: 0,
    y: 0,
    w: '100%',
    h: 0.5,
    fontSize: 16,
    color: lightColor,
    bold: true,
    align: 'center',
    fontFace: 'Arial'
  });
  
  // Process content into well-structured sections
  // First, break content into paragraphs for better processing
  const paragraphs = content.split('\n\n').filter(p => p.trim().length > 0);
  
  // Collect sections with their content
  const sections = [];
  let currentSection = null;
  
  // Group content by sections
  for (const paragraph of paragraphs) {
    const trimmedPara = paragraph.trim();
    
    // Skip empty paragraphs
    if (!trimmedPara) continue;
    
    // Check if this is a heading
    if (trimmedPara === trimmedPara.toUpperCase() || trimmedPara.startsWith('#')) {
      // Extract heading text
      const headingText = trimmedPara.startsWith('#') ? 
        trimmedPara.substring(1).trim() : trimmedPara;
      
      // Create a new section
      currentSection = {
        title: headingText,
        content: []
      };
      
      sections.push(currentSection);
    } else if (currentSection) {
      // Add content to the current section
      currentSection.content.push(trimmedPara);
    } else {
      // If no section yet, create a default one
      currentSection = {
        title: 'Overview',
        content: [trimmedPara]
      };
      
      sections.push(currentSection);
    }
  }
  
  // Create slides for each section with better formatting
  sections.forEach((section) => {
    // Create a new slide
    const slide = pptx.addSlide({ masterName: 'MAMA_MASTER' });
    
    // Add section title
    slide.addText(section.title, {
      x: 0.5,
      y: 0.7,
      w: 9,
      h: 0.5,
      fontSize: 28,
      color: primaryColor,
      bold: true,
      fontFace: 'Arial',
      align: 'left',
      wrap: true
    });
    
    // Add a decorative line
    slide.addShape('line', {
      x: 0.5,
      y: 1.3,
      w: 9,
      h: 0,
      line: { color: primaryColor, width: 2 }
    });
    
    // Starting position for content
    let yPos = 1.5;
    
    // Process content
    for (const contentItem of section.content) {
      // Check if this is a bullet list
      if (contentItem.includes('\n') && (
          contentItem.trim().startsWith('- ') || 
          contentItem.trim().startsWith('* ')
        )) {
        // Process as bullet points
        const bulletPoints = contentItem.split('\n')
          .filter(line => line.trim().length > 0)
          .map(line => line.trim().replace(/^[-*]\s/, '').trim());
        
        // Create a properly formatted bullet list
        slide.addText(bulletPoints.map(text => ({ 
          text: text,
          options: { bullet: true }
        })), {
          x: 0.6,
          y: yPos,
          w: 8.8,
          h: bulletPoints.length * 0.3 + 0.2,
          fontSize: 16,
          color: darkColor,
          fontFace: 'Arial',
          bullet: { type: 'bullet' },
          paraSpaceBefore: 6,
          paraSpaceAfter: 6,
          wrap: true
        });
        
        // Update position based on content length
        yPos += 0.2 + (bulletPoints.length * 0.25);
      } 
      // Check if content has numbered list format
      else if (contentItem.includes('\n') && contentItem.match(/^\d+\.\s/)) {
        // Process as numbered list
        const numberedPoints = contentItem.split('\n')
          .filter(line => line.trim().length > 0);
        
        // Create a properly formatted numbered list
        for (let i = 0; i < numberedPoints.length; i++) {
          const text = numberedPoints[i].replace(/^\d+\.\s/, '').trim();
          
          slide.addText(`${i+1}. ${text}`, {
            x: 0.6,
            y: yPos,
            w: 8.8,
            h: 0.3,
            fontSize: 16,
            color: darkColor,
            fontFace: 'Arial',
            paraSpaceBefore: 2,
            paraSpaceAfter: 2,
            wrap: true
          });
          
          yPos += 0.3; // Space between numbered items
        }
      }
      // Regular paragraph
      else {
        // Determine a reasonable height based on text length
        const estimatedLines = Math.ceil(contentItem.length / 60); // ~60 chars per line
        const estimatedHeight = Math.max(0.3, Math.min(3.0, estimatedLines * 0.16));
        
        // Format paragraph text with proper wrapping
        slide.addText(contentItem, {
          x: 0.5,
          y: yPos,
          w: 9,
          h: estimatedHeight,
          fontSize: 16,
          color: darkColor,
          fontFace: 'Arial',
          align: 'left',
          valign: 'top',
          paraSpaceBefore: 2,
          paraSpaceAfter: 4,
          wrap: true
        });
        
        // Update position
        yPos += estimatedHeight + 0.1;
      }
      
      // Add spacing between content items
      yPos += 0.1;
    }
  });
  
  // Save the PowerPoint
  await pptx.writeFile({
    fileName: `${topic.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_lesson_plan.pptx`
  });
};